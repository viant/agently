package conversation

import (
	"context"
	"embed"
	"fmt"
	"github.com/viant/datly"
	"github.com/viant/datly/repository"
	"github.com/viant/datly/repository/contract"
	"github.com/viant/datly/view"
	"github.com/viant/xdatly/handler/response"
	"github.com/viant/xdatly/types/core"
	"github.com/viant/xdatly/types/custom/dependency/checksum"
	"reflect"
	"time"
)

// Code generated by datly. DO NOT EDIT.
// This file was automatically generated and should not be modified manually.

func init() {
	core.RegisterType("conversation", "ConversationInput", reflect.TypeOf(ConversationInput{}), checksum.GeneratedTime)
	core.RegisterType("conversation", "ConversationOutput", reflect.TypeOf(ConversationOutput{}), checksum.GeneratedTime)
}

//go:embed conversation/*.sql
var ConversationFS embed.FS

type ConversationInput struct {
	Id                string                `parameter:",kind=path,in=id"`
	Since             string                `parameter:",kind=query,in=since" predicate:"expr,group=0,created_at >= (SELECT created_at FROM turn WHERE id = ?)"`
	IncludeTranscript bool                  `parameter:",kind=query,in=includeTranscript" predicate:"expr,group=0,?" value:"true"`
	IncludeModelCal   bool                  `parameter:",kind=query,in=includeModelCall" predicate:"expr,group=2,?" value:"false"`
	IncludeToolCall   bool                  `parameter:",kind=query,in=includeToolCall" predicate:"expr,group=3,?" value:"false"`
	Has               *ConversationInputHas `setMarker:"true" format:"-" sqlx:"-" diff:"-" json:"-"`
}

type ConversationInputHas struct {
	Id                bool
	Since             bool
	IncludeTranscript bool
	IncludeModelCal   bool
	IncludeToolCall   bool
}

type ConversationOutput struct {
	response.Status `parameter:",kind=output,in=status" json:",omitempty"`
	Data            []*ConversationView `parameter:",kind=output,in=view" view:"conversation,batch=10000,relationalConcurrency=1" sql:"uri=conversation/conversation.sql"`
	Metrics         response.Metrics    `parameter:",kind=output,in=metrics"`
}

type ConversationView struct {
	LastTurnId           *string           `sqlx:"last_turn_id"`
	Stage                string            `sqlx:"stage"`
	Id                   string            `sqlx:"id"`
	Summary              *string           `sqlx:"summary"`
	AgentName            *string           `sqlx:"agent_name"`
	LastActivity         *time.Time        `sqlx:"last_activity"`
	UsageInputTokens     *int              `sqlx:"usage_input_tokens"`
	UsageOutputTokens    *int              `sqlx:"usage_output_tokens"`
	UsageEmbeddingTokens *int              `sqlx:"usage_embedding_tokens"`
	CreatedAt            time.Time         `sqlx:"created_at"`
	UpdatedAt            *time.Time        `sqlx:"updated_at"`
	CreatedByUserId      *string           `sqlx:"created_by_user_id"`
	TenantId             *string           `sqlx:"tenant_id"`
	AgentId              *string           `sqlx:"agent_id"`
	AgentConfigId        *string           `sqlx:"agent_config_id"`
	DefaultModelProvider *string           `sqlx:"default_model_provider"`
	DefaultModel         *string           `sqlx:"default_model"`
	DefaultModelParams   *string           `sqlx:"default_model_params"`
	Title                *string           `sqlx:"title"`
	Metadata             *string           `sqlx:"metadata"`
	Visibility           string            `sqlx:"visibility"`
	Archived             int               `sqlx:"archived"`
	DeletedAt            *time.Time        `sqlx:"deleted_at"`
	LastMessageAt        *time.Time        `sqlx:"last_message_at"`
	MessageCount         int               `sqlx:"message_count"`
	TurnCount            int               `sqlx:"turn_count"`
	RetentionTtlDays     *int              `sqlx:"retention_ttl_days"`
	ExpiresAt            *time.Time        `sqlx:"expires_at"`
	Transcript           []*TranscriptView `view:",table=turn" on:"Id:id=ConversationId:conversation_id" sql:"uri=conversation/transcript.sql"`
	Usage                *UsageView        `view:",table=model_call" on:"Id:id=ConversationId:m.conversation_id" sql:"uri=conversation/usage.sql"`
}

type TranscriptView struct {
	Stage                 string         `sqlx:"stage"`
	Id                    string         `sqlx:"id"`
	ConversationId        string         `sqlx:"conversation_id"`
	CreatedAt             time.Time      `sqlx:"created_at"`
	Status                string         `sqlx:"status"`
	ErrorMessage          *string        `sqlx:"error_message"`
	StartedByMessageId    *string        `sqlx:"started_by_message_id"`
	RetryOf               *string        `sqlx:"retry_of"`
	AgentIdUsed           *string        `sqlx:"agent_id_used"`
	AgentConfigUsedId     *string        `sqlx:"agent_config_used_id"`
	ModelOverrideProvider *string        `sqlx:"model_override_provider"`
	ModelOverride         *string        `sqlx:"model_override"`
	ModelParamsOverride   *string        `sqlx:"model_params_override"`
	Message               []*MessageView `view:",table=message" on:"Id:id=TurnId:turn_id" sql:"uri=conversation/message.sql"`
}

type MessageView struct {
	AttachmentPayloadId  *string                  `sqlx:"attachment_payload_id"`
	Content              *string                  `sqlx:"content"`
	ContextSummary       *string                  `sqlx:"context_summary"`
	ConversationId       string                   `sqlx:"conversation_id"`
	CreatedAt            time.Time                `sqlx:"created_at"`
	CreatedByUserId      *string                  `sqlx:"created_by_user_id"`
	ElicitationId        *string                  `sqlx:"elicitation_id"`
	ElicitationPayloadId *string                  `sqlx:"elicitation_payload_id"`
	Id                   string                   `sqlx:"id"`
	Interim              int                      `sqlx:"interim"`
	ParentMessageId      *string                  `sqlx:"parent_message_id"`
	Role                 string                   `sqlx:"role"`
	Sequence             *int                     `sqlx:"sequence"`
	Status               *string                  `sqlx:"status"`
	SupersededBy         *string                  `sqlx:"superseded_by"`
	Tags                 *string                  `sqlx:"tags"`
	ToolName             *string                  `sqlx:"tool_name"`
	TurnId               *string                  `sqlx:"turn_id"`
	Type                 string                   `sqlx:"type"`
	UpdatedAt            *time.Time               `sqlx:"updated_at"`
	UserElicitationData  *UserElicitationDataView `view:",table=message" on:"Id:id=MessageId:m.id" sql:"uri=conversation/user_elicitation_data.sql"`
	Attachment           []*AttachmentView        `view:",table=message" on:"Id:id=ParentMessageId:m.parent_message_id" sql:"uri=conversation/attachment.sql"`
	ModelCall            *ModelCallView           `view:",table=model_call" on:"Id:id=MessageId:message_id" sql:"uri=conversation/model_call.sql"`
	ToolCall             *ToolCallView            `view:",table=tool_call" on:"Id:id=MessageId:message_id" sql:"uri=conversation/tool_call.sql"`
}

type UserElicitationDataView struct {
	InlineBody  *string `sqlx:"inline_body"`
	Compression string  `sqlx:"compression"`
	MessageId   string  `sqlx:"message_id" source:"id"`
}

type AttachmentView struct {
	InlineBody      *[]uint8 `sqlx:"inline_body"`
	Compression     string   `sqlx:"compression"`
	Uri             *string  `sqlx:"uri"`
	MimeType        string   `sqlx:"mime_type"`
	ParentMessageId *string  `sqlx:"parent_message_id"`
}

type ModelCallView struct {
	CacheHit                           int                  `sqlx:"cache_hit"`
	CacheKey                           *string              `sqlx:"cache_key"`
	CompletedAt                        *time.Time           `sqlx:"completed_at"`
	CompletionAcceptedPredictionTokens *int                 `sqlx:"completion_accepted_prediction_tokens"`
	CompletionAudioTokens              *int                 `sqlx:"completion_audio_tokens"`
	CompletionReasoningTokens          *int                 `sqlx:"completion_reasoning_tokens"`
	CompletionRejectedPredictionTokens *int                 `sqlx:"completion_rejected_prediction_tokens"`
	CompletionTokens                   *int                 `sqlx:"completion_tokens"`
	Cost                               *float64             `sqlx:"cost"`
	ErrorCode                          *string              `sqlx:"error_code"`
	ErrorMessage                       *string              `sqlx:"error_message"`
	FinishReason                       *string              `sqlx:"finish_reason"`
	LatencyMs                          *int                 `sqlx:"latency_ms"`
	MessageId                          string               `sqlx:"message_id"`
	Model                              string               `sqlx:"model"`
	ModelKind                          string               `sqlx:"model_kind"`
	PromptAudioTokens                  *int                 `sqlx:"prompt_audio_tokens"`
	PromptCachedTokens                 *int                 `sqlx:"prompt_cached_tokens"`
	PromptHash                         *string              `sqlx:"prompt_hash"`
	PromptRef                          *string              `sqlx:"prompt_ref"`
	PromptSnapshot                     *string              `sqlx:"prompt_snapshot"`
	PromptTokens                       *int                 `sqlx:"prompt_tokens"`
	Provider                           string               `sqlx:"provider"`
	ProviderRequestPayloadId           *string              `sqlx:"provider_request_payload_id"`
	ProviderResponsePayloadId          *string              `sqlx:"provider_response_payload_id"`
	Redacted                           int                  `sqlx:"redacted"`
	RedactionPolicyVersion             *string              `sqlx:"redaction_policy_version"`
	RequestPayloadId                   *string              `sqlx:"request_payload_id"`
	ResponsePayloadId                  *string              `sqlx:"response_payload_id"`
	ResponseRef                        *string              `sqlx:"response_ref"`
	ResponseSnapshot                   *string              `sqlx:"response_snapshot"`
	SafetyBlocked                      *int                 `sqlx:"safety_blocked"`
	SafetyReasons                      *string              `sqlx:"safety_reasons"`
	SpanId                             *string              `sqlx:"span_id"`
	StartedAt                          *time.Time           `sqlx:"started_at"`
	Status                             string               `sqlx:"status"`
	StreamPayloadId                    *string              `sqlx:"stream_payload_id"`
	TotalTokens                        *int                 `sqlx:"total_tokens"`
	TraceId                            *string              `sqlx:"trace_id"`
	TurnId                             *string              `sqlx:"turn_id"`
	ModelCallRequestPayload            *ResponsePayloadView `view:",table=call_payload" on:"RequestPayloadId:request_payload_id=Id:id" sql:"uri=conversation/model_call_request_payload.sql"`
	ModelCallProviderRequestPayload    *ResponsePayloadView `view:",table=call_payload" on:"ProviderRequestPayloadId:provider_request_payload_id=Id:id" sql:"uri=conversation/model_call_provider_request_payload.sql"`
	ModelCallResponsePayload           *ResponsePayloadView `view:",table=call_payload" on:"ResponsePayloadId:response_payload_id=Id:id" sql:"uri=conversation/model_call_response_payload.sql"`
	ModelCallProviderResponsePayload   *ResponsePayloadView `view:",table=call_payload" on:"ProviderResponsePayloadId:provider_response_payload_id=Id:id" sql:"uri=conversation/model_call_provider_response_payload.sql"`
	ModelCallStreamPayload             *ResponsePayloadView `view:",table=call_payload" on:"StreamPayloadId:stream_payload_id=Id:id" sql:"uri=conversation/model_call_stream_payload.sql"`
}

type ResponsePayloadView struct {
	Id          string  `sqlx:"id"`
	InlineBody  *string `sqlx:"inline_body"`
	Compression string  `sqlx:"compression"`
}

type ToolCallView struct {
	Attempt           int                  `sqlx:"attempt"`
	CapabilityTags    *string              `sqlx:"capability_tags"`
	CompletedAt       *time.Time           `sqlx:"completed_at"`
	Cost              *float64             `sqlx:"cost"`
	ErrorCode         *string              `sqlx:"error_code"`
	ErrorMessage      *string              `sqlx:"error_message"`
	LatencyMs         *int                 `sqlx:"latency_ms"`
	MessageId         string               `sqlx:"message_id"`
	OpId              string               `sqlx:"op_id"`
	RequestHash       *string              `sqlx:"request_hash"`
	RequestPayloadId  *string              `sqlx:"request_payload_id"`
	RequestRef        *string              `sqlx:"request_ref"`
	RequestSnapshot   *string              `sqlx:"request_snapshot"`
	ResourceUris      *string              `sqlx:"resource_uris"`
	ResponsePayloadId *string              `sqlx:"response_payload_id"`
	ResponseRef       *string              `sqlx:"response_ref"`
	ResponseSnapshot  *string              `sqlx:"response_snapshot"`
	Retriable         *int                 `sqlx:"retriable"`
	SpanId            *string              `sqlx:"span_id"`
	StartedAt         *time.Time           `sqlx:"started_at"`
	Status            string               `sqlx:"status"`
	ToolKind          string               `sqlx:"tool_kind"`
	ToolName          string               `sqlx:"tool_name"`
	TraceId           *string              `sqlx:"trace_id"`
	TurnId            *string              `sqlx:"turn_id"`
	RequestPayload    *ResponsePayloadView `view:",table=call_payload" on:"RequestPayloadId:request_payload_id=Id:id" sql:"uri=conversation/request_payload.sql"`
	ResponsePayload   *ResponsePayloadView `view:",table=call_payload" on:"ResponsePayloadId:response_payload_id=Id:id" sql:"uri=conversation/response_payload.sql"`
}

type UsageView struct {
	ConversationId                     string       `sqlx:"conversation_id"`
	PromptTokens                       *int         `sqlx:"prompt_tokens"`
	PromptCachedTokens                 *int         `sqlx:"prompt_cached_tokens"`
	PromptAudioTokens                  *int         `sqlx:"prompt_audio_tokens"`
	CompletionTokens                   *int         `sqlx:"completion_tokens"`
	CompletionReasoningTokens          *int         `sqlx:"completion_reasoning_tokens"`
	CompletionAudioTokens              *int         `sqlx:"completion_audio_tokens"`
	CompletionAcceptedPredictionTokens *int         `sqlx:"completion_accepted_prediction_tokens"`
	CompletionRejectedPredictionTokens *int         `sqlx:"completion_rejected_prediction_tokens"`
	TotalTokens                        *int         `sqlx:"total_tokens"`
	Model                              []*ModelView `view:",table=model_call" on:"ConversationId:m.conversation_id=ConversationId:m.conversation_id" sql:"uri=conversation/model.sql"`
}

type ModelView struct {
	ConversationId                     string `sqlx:"conversation_id"`
	Model                              string `sqlx:"model"`
	PromptTokens                       *int   `sqlx:"prompt_tokens"`
	PromptCachedTokens                 *int   `sqlx:"prompt_cached_tokens"`
	PromptAudioTokens                  *int   `sqlx:"prompt_audio_tokens"`
	CompletionTokens                   *int   `sqlx:"completion_tokens"`
	CompletionReasoningTokens          *int   `sqlx:"completion_reasoning_tokens"`
	CompletionAudioTokens              *int   `sqlx:"completion_audio_tokens"`
	CompletionAcceptedPredictionTokens *int   `sqlx:"completion_accepted_prediction_tokens"`
	CompletionRejectedPredictionTokens *int   `sqlx:"completion_rejected_prediction_tokens"`
	TotalTokens                        *int   `sqlx:"total_tokens"`
}

var ConversationPathURI = "/v1/api/agently/conversation/{id}"

func DefineConversationComponent(ctx context.Context, srv *datly.Service) error {
	aComponent, err := repository.NewComponent(
		contract.NewPath("GET", ConversationPathURI),
		repository.WithResource(srv.Resource()),
		repository.WithContract(
			reflect.TypeOf(ConversationInput{}),
			reflect.TypeOf(ConversationOutput{}), &ConversationFS, view.WithConnectorRef("agently")))

	if err != nil {
		return fmt.Errorf("failed to create Conversation component: %w", err)
	}
	if err := srv.AddComponent(ctx, aComponent); err != nil {
		return fmt.Errorf("failed to add Conversation component: %w", err)
	}
	return nil
}

func (i *ConversationInput) EmbedFS() *embed.FS {
	return &ConversationFS
}
