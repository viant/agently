package conversation

import (
	"context"
	"embed"
	"fmt"
	"github.com/viant/agently/genai/tool"
	"github.com/viant/datly"
	"github.com/viant/datly/repository"
	"github.com/viant/datly/repository/contract"
	"github.com/viant/datly/view"
	"github.com/viant/xdatly/handler/response"
	"github.com/viant/xdatly/types/core"
	"github.com/viant/xdatly/types/custom/dependency/checksum"
	"reflect"
	"time"
)

// Code generated by datly. DO NOT EDIT.
// This file was automatically generated and should not be modified manually.

func init() {
	core.RegisterType("conversation", "ConversationInput", reflect.TypeOf(ConversationInput{}), checksum.GeneratedTime)
	core.RegisterType("conversation", "ConversationOutput", reflect.TypeOf(ConversationOutput{}), checksum.GeneratedTime)
}

//go:embed conversation/*.sql
var ConversationFS embed.FS

type ConversationInput struct {
	Id                string                `parameter:",kind=path,in=id" predicate:"equal,group=0,t,id"`
	Since             string                `parameter:",kind=query,in=since" predicate:"expr,group=1,EXISTS (SELECT 1 FROM turn a WHERE a.id = ? AND (created_at >= a.created_at OR (queue_seq IS NOT NULL AND a.queue_seq IS NOT NULL AND queue_seq >= a.queue_seq)))"`
	IncludeTranscript bool                  `parameter:",kind=query,in=includeTranscript" predicate:"expr,group=1,?" value:"true"`
	IncludeModelCal   bool                  `parameter:",kind=query,in=includeModelCall" predicate:"expr,group=2,?" value:"false"`
	IncludeToolCall   bool                  `parameter:",kind=query,in=includeToolCall" predicate:"expr,group=3,?" value:"false"`
	AgentId           string                `parameter:",kind=query,in=agentId" predicate:"expr,group=0,t.agent_id = ?"`
	ParentId          string                `parameter:",kind=query,in=parentId" predicate:"expr,group=0,t.conversation_parent_id = ?"`
	ParentTurnId      string                `parameter:",kind=query,in=parentTurnId" predicate:"expr,group=0,t.conversation_parent_turn_id = ?"`
	ScheduleId        string                `parameter:",kind=query,in=scheduleId" predicate:"expr,group=0,t.schedule_id = ?"`
	ScheduleRunId     string                `parameter:",kind=query,in=scheduleRunId" predicate:"expr,group=0,t.schedule_run_id = ?"`
	HasScheduleId     bool                  `parameter:",kind=query,in=hasScheduleId" predicate:"expr,group=0,t.schedule_id IS NOT NULL"`
	DefaultPredicate  string                `parameter:",kind=const,in=value" predicate:"handler,group=0,*conversation.Filter" value:"0"`
	FeedSpec          []*tool.FeedSpec      `parameter:",kind=transient,in=extension"`
	Has               *ConversationInputHas `setMarker:"true" format:"-" sqlx:"-" diff:"-" json:"-"`
}

type ConversationInputHas struct {
	Id                bool
	Since             bool
	IncludeTranscript bool
	IncludeModelCal   bool
	IncludeToolCall   bool
	AgentId           bool
	ParentId          bool
	ParentTurnId      bool
	ScheduleId        bool
	ScheduleRunId     bool
	HasScheduleId     bool
	DefaultPredicate  bool
	FeedSpec          bool
}

type ConversationOutput struct {
	response.Status `parameter:",kind=output,in=status" json:",omitempty"`
	Data            []*ConversationView `parameter:",kind=output,in=view" view:"conversation,batch=10000,relationalConcurrency=1" sql:"uri=conversation/conversation.sql"`
	Metrics         response.Metrics    `parameter:",kind=output,in=metrics"`
}

type ConversationView struct {
	LastTurnId               *string           `sqlx:"last_turn_id"`
	Stage                    string            `sqlx:"stage"`
	Id                       string            `sqlx:"id"`
	Summary                  *string           `sqlx:"summary"`
	LastActivity             *time.Time        `sqlx:"last_activity"`
	UsageInputTokens         *int              `sqlx:"usage_input_tokens"`
	UsageOutputTokens        *int              `sqlx:"usage_output_tokens"`
	UsageEmbeddingTokens     *int              `sqlx:"usage_embedding_tokens"`
	CreatedAt                time.Time         `sqlx:"created_at"`
	UpdatedAt                *time.Time        `sqlx:"updated_at"`
	CreatedByUserId          *string           `sqlx:"created_by_user_id"`
	AgentId                  *string           `sqlx:"agent_id"`
	DefaultModelProvider     *string           `sqlx:"default_model_provider"`
	DefaultModel             *string           `sqlx:"default_model"`
	DefaultModelParams       *string           `sqlx:"default_model_params"`
	Title                    *string           `sqlx:"title"`
	ConversationParentId     *string           `sqlx:"conversation_parent_id"`
	ConversationParentTurnId *string           `sqlx:"conversation_parent_turn_id"`
	Metadata                 *string           `sqlx:"metadata"`
	Visibility               string            `sqlx:"visibility"`
	Shareable                *int              `sqlx:"shareable"`
	Status                   *string           `sqlx:"status"`
	Scheduled                *int              `sqlx:"scheduled"`
	ScheduleId               *string           `sqlx:"schedule_id"`
	ScheduleRunId            *string           `sqlx:"schedule_run_id"`
	ScheduleKind             *string           `sqlx:"schedule_kind"`
	ScheduleTimezone         *string           `sqlx:"schedule_timezone"`
	ScheduleCronExpr         *string           `sqlx:"schedule_cron_expr"`
	ExternalTaskRef          *string           `sqlx:"external_task_ref"`
	Transcript               []*TranscriptView `view:",table=turn" on:"Id:id=ConversationId:conversation_id" sql:"uri=conversation/transcript.sql"`
	Usage                    *UsageView        `view:",table=model_call" on:"Id:id=ConversationId:m.conversation_id" sql:"uri=conversation/usage.sql"`
}

type TranscriptView struct {
	ElapsedInSec          int            `sqlx:"elapsedInSec"`
	Stage                 string         `sqlx:"stage"`
	ToolFeed              []*tool.Feed   `sqlx:"-"`
	Id                    string         `sqlx:"id"`
	ConversationId        string         `sqlx:"conversation_id"`
	CreatedAt             time.Time      `sqlx:"created_at"`
	QueueSeq              *int           `sqlx:"queue_seq"`
	Status                string         `sqlx:"status"`
	ErrorMessage          *string        `sqlx:"error_message"`
	StartedByMessageId    *string        `sqlx:"started_by_message_id"`
	RetryOf               *string        `sqlx:"retry_of"`
	AgentIdUsed           *string        `sqlx:"agent_id_used"`
	AgentConfigUsedId     *string        `sqlx:"agent_config_used_id"`
	ModelOverrideProvider *string        `sqlx:"model_override_provider"`
	ModelOverride         *string        `sqlx:"model_override"`
	ModelParamsOverride   *string        `sqlx:"model_params_override"`
	Message               []*MessageView `view:",table=message" on:"Id:id=TurnId:turn_id" sql:"uri=conversation/message.sql"`
}

type MessageView struct {
	Archived             *int                     `sqlx:"archived"`
	AttachmentPayloadId  *string                  `sqlx:"attachment_payload_id"`
	Content              *string                  `sqlx:"content"`
	ContextSummary       *string                  `sqlx:"context_summary"`
	ConversationId       string                   `sqlx:"conversation_id"`
	CreatedAt            time.Time                `sqlx:"created_at"`
	CreatedByUserId      *string                  `sqlx:"created_by_user_id"`
	ElicitationId        *string                  `sqlx:"elicitation_id"`
	ElicitationPayloadId *string                  `sqlx:"elicitation_payload_id"`
	EmbeddingIndex       *string                  `sqlx:"embedding_index"`
	Id                   string                   `sqlx:"id"`
	Interim              int                      `sqlx:"interim"`
	LinkedConversationId *string                  `sqlx:"linked_conversation_id"`
	Mode                 *string                  `sqlx:"mode"`
	ParentMessageId      *string                  `sqlx:"parent_message_id"`
	RawContent           *string                  `sqlx:"raw_content"`
	Role                 string                   `sqlx:"role"`
	Sequence             *int                     `sqlx:"sequence"`
	Status               *string                  `sqlx:"status"`
	Summary              *string                  `sqlx:"summary"`
	SupersededBy         *string                  `sqlx:"superseded_by"`
	Tags                 *string                  `sqlx:"tags"`
	ToolName             *string                  `sqlx:"tool_name"`
	TurnId               *string                  `sqlx:"turn_id"`
	Type                 string                   `sqlx:"type"`
	UpdatedAt            *time.Time               `sqlx:"updated_at"`
	UserElicitationData  *UserElicitationDataView `view:",table=message" on:"Id:id=MessageId:m.id" sql:"uri=conversation/user_elicitation_data.sql"`
	LinkedConversation   *LinkedConversationView  `view:",table=conversation" on:"LinkedConversationId:linked_conversation_id=Id:id" sql:"uri=conversation/linked_conversation.sql"`
	Attachment           []*AttachmentView        `view:",table=message" on:"Id:id=ParentMessageId:m.parent_message_id" sql:"uri=conversation/attachment.sql"`
	ModelCall            *ModelCallView           `view:",table=model_call" on:"Id:id=MessageId:message_id" sql:"uri=conversation/model_call.sql"`
	ToolCall             *ToolCallView            `view:",table=tool_call" on:"Id:id=MessageId:message_id" sql:"uri=conversation/tool_call.sql"`
}

type UserElicitationDataView struct {
	InlineBody  *string `sqlx:"inline_body"`
	Compression string  `sqlx:"compression"`
	MessageId   string  `sqlx:"message_id" source:"id"`
}

type LinkedConversationView struct {
	Id        string     `sqlx:"id"`
	Status    *string    `sqlx:"status"`
	CreatedAt time.Time  `sqlx:"created_at"`
	UpdatedAt *time.Time `sqlx:"updated_at"`
}

type AttachmentView struct {
	InlineBody      *[]uint8 `sqlx:"inline_body"`
	Compression     string   `sqlx:"compression"`
	Uri             *string  `sqlx:"uri"`
	MimeType        string   `sqlx:"mime_type"`
	ParentMessageId *string  `sqlx:"parent_message_id"`
}

type ModelCallView struct {
	CompletedAt                        *time.Time           `sqlx:"completed_at"`
	CompletionAcceptedPredictionTokens *int                 `sqlx:"completion_accepted_prediction_tokens"`
	CompletionAudioTokens              *int                 `sqlx:"completion_audio_tokens"`
	CompletionReasoningTokens          *int                 `sqlx:"completion_reasoning_tokens"`
	CompletionRejectedPredictionTokens *int                 `sqlx:"completion_rejected_prediction_tokens"`
	CompletionTokens                   *int                 `sqlx:"completion_tokens"`
	Cost                               *float64             `sqlx:"cost"`
	ErrorCode                          *string              `sqlx:"error_code"`
	ErrorMessage                       *string              `sqlx:"error_message"`
	FinishReason                       *string              `sqlx:"finish_reason"`
	LatencyMs                          *int                 `sqlx:"latency_ms"`
	MessageId                          string               `sqlx:"message_id"`
	Model                              string               `sqlx:"model"`
	ModelKind                          string               `sqlx:"model_kind"`
	PromptAudioTokens                  *int                 `sqlx:"prompt_audio_tokens"`
	PromptCachedTokens                 *int                 `sqlx:"prompt_cached_tokens"`
	PromptTokens                       *int                 `sqlx:"prompt_tokens"`
	Provider                           string               `sqlx:"provider"`
	ProviderRequestPayloadId           *string              `sqlx:"provider_request_payload_id"`
	ProviderResponsePayloadId          *string              `sqlx:"provider_response_payload_id"`
	RequestPayloadId                   *string              `sqlx:"request_payload_id"`
	ResponsePayloadId                  *string              `sqlx:"response_payload_id"`
	SpanId                             *string              `sqlx:"span_id"`
	StartedAt                          *time.Time           `sqlx:"started_at"`
	Status                             string               `sqlx:"status"`
	StreamPayloadId                    *string              `sqlx:"stream_payload_id"`
	TotalTokens                        *int                 `sqlx:"total_tokens"`
	TraceId                            *string              `sqlx:"trace_id"`
	TurnId                             *string              `sqlx:"turn_id"`
	ModelCallRequestPayload            *ResponsePayloadView `view:",table=call_payload" on:"RequestPayloadId:request_payload_id=Id:id" sql:"uri=conversation/model_call_request_payload.sql"`
	ModelCallProviderRequestPayload    *ResponsePayloadView `view:",table=call_payload" on:"ProviderRequestPayloadId:provider_request_payload_id=Id:id" sql:"uri=conversation/model_call_provider_request_payload.sql"`
	ModelCallResponsePayload           *ResponsePayloadView `view:",table=call_payload" on:"ResponsePayloadId:response_payload_id=Id:id" sql:"uri=conversation/model_call_response_payload.sql"`
	ModelCallProviderResponsePayload   *ResponsePayloadView `view:",table=call_payload" on:"ProviderResponsePayloadId:provider_response_payload_id=Id:id" sql:"uri=conversation/model_call_provider_response_payload.sql"`
	ToolCallLinks                      []*ToolCallLinksView `view:",table=tool_call" on:"TraceId:trace_id=TraceId:trace_id" sql:"uri=conversation/tool_call_links.sql"`
	ModelCallStreamPayload             *ResponsePayloadView `view:",table=call_payload" on:"StreamPayloadId:stream_payload_id=Id:id" sql:"uri=conversation/model_call_stream_payload.sql"`
}

type ResponsePayloadView struct {
	Id          string  `sqlx:"id"`
	InlineBody  *string `sqlx:"inline_body"`
	Compression string  `sqlx:"compression"`
}

type ToolCallLinksView struct {
	MessageId string  `sqlx:"message_id"`
	OpId      string  `sqlx:"op_id"`
	TraceId   *string `sqlx:"trace_id"`
}

type ToolCallView struct {
	Attempt           int                  `sqlx:"attempt"`
	CompletedAt       *time.Time           `sqlx:"completed_at"`
	Cost              *float64             `sqlx:"cost"`
	ErrorCode         *string              `sqlx:"error_code"`
	ErrorMessage      *string              `sqlx:"error_message"`
	LatencyMs         *int                 `sqlx:"latency_ms"`
	MessageId         string               `sqlx:"message_id"`
	OpId              string               `sqlx:"op_id"`
	RequestHash       *string              `sqlx:"request_hash"`
	RequestPayloadId  *string              `sqlx:"request_payload_id"`
	ResponsePayloadId *string              `sqlx:"response_payload_id"`
	Retriable         *int                 `sqlx:"retriable"`
	SpanId            *string              `sqlx:"span_id"`
	StartedAt         *time.Time           `sqlx:"started_at"`
	Status            string               `sqlx:"status"`
	ToolKind          string               `sqlx:"tool_kind"`
	ToolName          string               `sqlx:"tool_name"`
	TraceId           *string              `sqlx:"trace_id"`
	TurnId            *string              `sqlx:"turn_id"`
	RequestPayload    *ResponsePayloadView `view:",table=call_payload" on:"RequestPayloadId:request_payload_id=Id:id" sql:"uri=conversation/request_payload.sql"`
	ResponsePayload   *ResponsePayloadView `view:",table=call_payload" on:"ResponsePayloadId:response_payload_id=Id:id" sql:"uri=conversation/response_payload.sql"`
}

type UsageView struct {
	ConversationId                     string       `sqlx:"conversation_id"`
	Cost                               *float64     `sqlx:"cost"`
	PromptTokens                       *int         `sqlx:"prompt_tokens"`
	PromptCachedTokens                 *int         `sqlx:"prompt_cached_tokens"`
	PromptAudioTokens                  *int         `sqlx:"prompt_audio_tokens"`
	CompletionTokens                   *int         `sqlx:"completion_tokens"`
	CompletionReasoningTokens          *int         `sqlx:"completion_reasoning_tokens"`
	CompletionAudioTokens              *int         `sqlx:"completion_audio_tokens"`
	CompletionAcceptedPredictionTokens *int         `sqlx:"completion_accepted_prediction_tokens"`
	CompletionRejectedPredictionTokens *int         `sqlx:"completion_rejected_prediction_tokens"`
	TotalTokens                        *int         `sqlx:"total_tokens"`
	Model                              []*ModelView `view:",table=model_call" on:"ConversationId:m.conversation_id=ConversationId:m.conversation_id" sql:"uri=conversation/model.sql"`
}

type ModelView struct {
	ConversationId                     string   `sqlx:"conversation_id"`
	Model                              string   `sqlx:"model"`
	PromptTokens                       *int     `sqlx:"prompt_tokens"`
	PromptCachedTokens                 *int     `sqlx:"prompt_cached_tokens"`
	PromptAudioTokens                  *int     `sqlx:"prompt_audio_tokens"`
	CompletionTokens                   *int     `sqlx:"completion_tokens"`
	CompletionReasoningTokens          *int     `sqlx:"completion_reasoning_tokens"`
	CompletionAudioTokens              *int     `sqlx:"completion_audio_tokens"`
	CompletionAcceptedPredictionTokens *int     `sqlx:"completion_accepted_prediction_tokens"`
	CompletionRejectedPredictionTokens *int     `sqlx:"completion_rejected_prediction_tokens"`
	TotalTokens                        *int     `sqlx:"total_tokens"`
	Cost                               *float64 `sqlx:"cost"`
}

var ConversationPathURI = "/v1/api/agently/conversation/{id}"

func DefineConversationComponent(ctx context.Context, srv *datly.Service) error {
	aComponent, err := repository.NewComponent(
		contract.NewPath("GET", ConversationPathURI),
		repository.WithResource(srv.Resource()),
		repository.WithContract(
			reflect.TypeOf(ConversationInput{}),
			reflect.TypeOf(ConversationOutput{}), &ConversationFS, view.WithConnectorRef("agently")))

	if err != nil {
		return fmt.Errorf("failed to create Conversation component: %w", err)
	}
	if err := srv.AddComponent(ctx, aComponent); err != nil {
		return fmt.Errorf("failed to add Conversation component: %w", err)
	}
	return nil
}

func (i *ConversationInput) EmbedFS() *embed.FS {
	return &ConversationFS
}
