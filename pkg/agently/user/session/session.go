package session

import (
	"context"
	"embed"
	"fmt"
	"reflect"
	"time"

	"github.com/viant/datly"
	"github.com/viant/datly/repository"
	"github.com/viant/datly/repository/contract"
	"github.com/viant/datly/view"
	"github.com/viant/xdatly/handler/response"
	"github.com/viant/xdatly/types/core"
	"github.com/viant/xdatly/types/custom/dependency/checksum"
)

// Code generated by datly. DO NOT EDIT.
// This file was manually adapted to mirror existing OAuth token components.

func init() {
	core.RegisterType("session", "SessionInput", reflect.TypeOf(SessionInput{}), checksum.GeneratedTime)
	core.RegisterType("session", "SessionOutput", reflect.TypeOf(SessionOutput{}), checksum.GeneratedTime)
}

//go:embed session/*.sql
var SessionFS embed.FS

type SessionInput struct {
	Id  string           `parameter:",kind=query,in=id" predicate:"equal,group=0,s,id"`
	Has *SessionInputHas `setMarker:"true" format:"-" sqlx:"-" diff:"-" json:"-"`
}

type SessionInputHas struct {
	Id bool
}

type SessionOutput struct {
	response.Status `parameter:",kind=output,in=status" json:",omitempty"`
	Data            []*SessionView   `parameter:",kind=output,in=view" view:"session,batch=10000,relationalConcurrency=1" sql:"uri=session/session.sql"`
	Metrics         response.Metrics `parameter:",kind=output,in=metrics"`
}

type SessionView struct {
	Id        string     `sqlx:"id"`
	UserId    string     `sqlx:"user_id"`
	Provider  string     `sqlx:"provider"`
	CreatedAt time.Time  `sqlx:"created_at"`
	UpdatedAt *time.Time `sqlx:"updated_at"`
	ExpiresAt time.Time  `sqlx:"expires_at"`
}

var SessionPathURI = "/v1/api/agently/user/session"

func DefineSessionComponent(ctx context.Context, srv *datly.Service) error {
	aComponent, err := repository.NewComponent(
		contract.NewPath("GET", SessionPathURI),
		repository.WithResource(srv.Resource()),
		repository.WithContract(
			reflect.TypeOf(SessionInput{}),
			reflect.TypeOf(SessionOutput{}), &SessionFS, view.WithConnectorRef("agently")),
	)

	if err != nil {
		return fmt.Errorf("failed to create Session component: %w", err)
	}
	if err := srv.AddComponent(ctx, aComponent); err != nil {
		return fmt.Errorf("failed to add Session component: %w", err)
	}
	return nil
}

func (i *SessionInput) EmbedFS() *embed.FS { return &SessionFS }
