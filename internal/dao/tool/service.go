package tool

import (
	"context"
	"encoding/json"
	"fmt"
	domain "github.com/viant/agently/genai/tool"
	post2 "github.com/viant/agently/internal/dao/tool/post"
	"github.com/viant/datly"
	"github.com/viant/datly/repository"
	"github.com/viant/datly/repository/contract"
	"github.com/viant/datly/view"
	"net/http"
)

type Service struct {
	dao *datly.Service
}

// Ensure Service implements domain.DAO at compile time.
var _ domain.DAO = (*Service)(nil)

// toPost converts business Call to generated POST DTO.
func toPost(c *domain.Call) *post2.ToolCall {
	if c == nil {
		return nil
	}
	return &post2.ToolCall{
		Id:             c.ID,
		ConversationId: optionalStringPtr(c.ConversationID),
		ToolName:       c.ToolName,
		Arguments:      c.Arguments,
		Result:         c.Result,
		Succeeded:      c.Succeeded,
		ErrorMsg:       c.ErrorMsg,
		StartedAt:      c.StartedAt,
		FinishedAt:     c.FinishedAt,
	}
}

// fromView converts generated view to business Call.
func fromView(v *ToolCallView) *domain.Call {
	if v == nil {
		return nil
	}
	return &domain.Call{
		ID:             v.Id,
		ConversationID: v.ConversationId,
		ToolName:       v.ToolName,
		Arguments:      v.Arguments,
		Result:         v.Result,
		Succeeded:      v.Succeeded,
		ErrorMsg:       v.ErrorMsg,
		StartedAt:      v.StartedAt,
		FinishedAt:     v.FinishedAt,
	}
}

func optionalStringPtr(s string) *string {
	if s == "" {
		return nil
	}
	return &s
}

// Add records a tool-call entry using the underlying POST component generated by Datly.
// It returns an error when validation fails or the SQL insert cannot be executed.
func (s *Service) Add(ctx context.Context, call *domain.Call) error {
	if call == nil {
		return fmt.Errorf("tool call is nil")
	}

	// Build the POST input payload expected by the auto-generated handler.
	input := post2.Input{
		ToolCall: []*post2.ToolCall{toPost(call)},
	}

	output := &post2.Output{}

	// Execute through datly runtime â€“ the path must match the POST handler contract.
	_, err := s.dao.Operate(ctx,
		datly.WithOutput(output),
		datly.WithInput(&input),
		datly.WithPath(contract.NewPath(http.MethodPost, post2.PathURI)),
	)
	if err != nil {
		return err
	}

	if len(output.Violations) > 0 {
		data, _ := json.Marshal(output.Violations)
		return fmt.Errorf("failed to add tool call: %s", data)
	}
	return nil
}

// List returns tool-call records filtered by conversationID (if provided).
// When conversationID is empty all records are returned (use with caution).
func (s *Service) List(ctx context.Context, conversationID string) ([]*domain.Call, error) {
	out := &ToolCallOutput{}

	// Prepare input with optional filter.
	in := &ToolCallInput{
		ConversationId: conversationID,
		Has:            &ToolCallInputHas{ConversationId: true},
	}

	_, err := s.dao.Operate(ctx,
		datly.WithOutput(out),
		datly.WithInput(in),
		datly.WithURI(ToolCallPathURI),
	)
	if err != nil {
		return nil, err
	}
	var calls []*domain.Call
	for _, v := range out.Data {
		calls = append(calls, fromView(v))
	}
	return calls, nil
}

func (s *Service) init(ctx context.Context) error {
	if err := DefineToolCallComponent(ctx, s.dao); err != nil {
		return err
	}
	if _, err := post2.DefineComponent(ctx, s.dao); err != nil {
		return err
	}
	return nil
}

func New(ctx context.Context, connector *view.Connector, options ...repository.Option) (*Service, error) {
	dao, err := datly.New(ctx, options...)
	if err != nil {
		return nil, err
	}
	if err := dao.AddConnectors(ctx, connector); err != nil {
		return nil, err
	}
	ret := &Service{
		dao: dao,
	}
	err = ret.init(ctx)
	return ret, err
}
