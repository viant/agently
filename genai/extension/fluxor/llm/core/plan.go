package core

import (
	"context"
	_ "embed"
	"encoding/json"
	"github.com/google/uuid"
	plan "github.com/viant/agently/genai/agent/plan"
	"github.com/viant/agently/genai/llm"
	"github.com/viant/agently/genai/memory"
)

// Plan represents a structured Plan generated by the LLM.
//
//go:embed prompt/plan_prompt.vm
var planPromptTemplate string

// PlanInput defines input for Plan generation or finalization.
type PlanInput struct {
	Query     string   `json:"query"`
	Context   string   `json:"context,omitempty"`
	Model     string   `json:"model,omitempty"`
	Tools     []string `json:"tools,omitempty"`     // available tools for selection
	PromptURI string   `json:"promptURI,omitempty"` // optional custom prompt for Plan generation
	//Loopback parameters
	Results       []plan.Result    `json:"results,omitempty"`    // structured step results for finalization
	Transcript    []memory.Message `json:"transcript,omitempty"` // transcript of the conversation with the LLM`
	ResultSummary string           `json:"resultSummary,omitempty"`
}

// PlanOutput defines Plan or Answer output.
type PlanOutput struct {
	Plan          *plan.Plan       `json:"plan,omitempty"`
	Answer        string           `json:"answer,omitempty"`
	Results       []plan.Result    `json:"results,omitempty"`
	Transcript    []memory.Message `json:"transcript,omitempty"` // transcript of the conversation with the LLM`
	ResultSummary string           `json:"resultSummary,omitempty"`
}

// Plan calls the LLM to generate a YAML-encoded Plan
func (s *Service) plan(ctx context.Context, in, out interface{}) error {
	input := in.(*PlanInput)
	output := out.(*PlanOutput)
	return s.Plan(ctx, input, output)
}

// Plan generates a structured Plan based on the provided input.
func (s *Service) Plan(ctx context.Context, input *PlanInput, output *PlanOutput) error {
	output.Results = input.Results
	output.Transcript = input.Transcript
	modelName := input.Model
	if modelName == "" {
		modelName = s.defaultModel
	}
	tools, err := s.registry.MustHaveTools(input.Tools)
	if err != nil {
		return err
	}

	promptTemplate := ""
	if input.PromptURI != "" {
		data, err := s.fs.DownloadWithURL(ctx, input.PromptURI)
		if err != nil {
			return err
		}
		promptTemplate = string(data)
	}
	if promptTemplate == "" {
		promptTemplate = planPromptTemplate
	}
	genOutput := &GenerateOutput{}
	planResult, err := s.GeneratePlan(ctx, modelName, promptTemplate, input, tools, genOutput)
	if err != nil {
		return err
	}
	if planResult.Elicitation.IsEmpty() {
		planResult.Elicitation = nil
	}

	for _, choice := range genOutput.Response.Choices {
		if choice.Message.Role == llm.RoleAssistant {
			output.Transcript = append(output.Transcript, memory.Message{Role: string(choice.Message.Role), Content: choice.Message.Content})
		}
	}

	for _, transcript := range output.Transcript {
		output.Answer += transcript.Content + "\n"
	}

	planResult = RefinePlan(input.Results, planResult)
	output.Plan = &planResult
	output.Results = input.Results
	return nil
}

func RefinePlan(results []plan.Result, result plan.Plan) plan.Plan {

	if len(result.Steps) == 0 {
		return result
	}

	var stepsCount = len(result.Steps)
	var byTool = make(map[string]*plan.Result)

	for i := len(results); i > 0; i-- {
		result := results[i-1]
		byTool[result.Name] = &result
		if len(byTool) == stepsCount {
			break
		}
	}

	var steps = make(plan.Steps, 0, len(result.Steps))
	for i := range result.Steps {
		step := result.Steps[i]
		if res, ok := byTool[step.Name]; ok {
			if MapEqual(res.Args, step.Args) {
				continue
			}
		}
		steps = append(steps, step)
	}
	result.Steps = steps
	return result
}

// GeneratePlan invokes the LLM to produce or refine a plan based on the template and bind variables.
// It returns a Plan if parsing succeeded, otherwise returns the answer text.
func (s *Service) GeneratePlan(ctx context.Context, modelName, promptTemplate string, input *PlanInput, tools []llm.Tool, genOutput *GenerateOutput) (plan.Plan, error) {

	bind := map[string]interface{}{
		"Query":         input.Query,
		"Context":       input.Context,
		"Results":       input.Results,
		"Tools":         input.Tools,
		"ResultSummary": input.ResultSummary,
	}

	s.enureResultCallID(input)

	genInput := &GenerateInput{
		Model:    modelName,
		Template: promptTemplate,
		Bind:     bind,
		Tools:    tools,
	}

	if len(input.Results) > 0 {
		var toolCalls []llm.ToolCall
		var toolResultMessage []llm.Message
		for _, result := range input.Results {
			toolCall := llm.NewToolCall(result.ID, result.Name, result.Args)
			toolCalls = append(toolCalls, toolCall)
			callResult := result.Result
			if result.Error != "" {
				callResult = "Error:" + result.Error
			}
			toolResultMessage = append(toolResultMessage, llm.NewToolResultMessage(toolCall, callResult))
		}

		genInput.Message = append(genInput.Message, llm.NewAssistantMessageWithToolCalls(toolCalls...))
		genInput.Message = append(genInput.Message, toolResultMessage...)

	}

	aPlan, err := s.generatePlan(ctx, genInput, genOutput)
	return aPlan, err
}

func (s *Service) enureResultCallID(input *PlanInput) {
	for i := range input.Results {
		result := input.Results[i]
		if result.ID == "" {
			result.ID = uuid.New().String()
		}
	}
}

func (s *Service) generatePlan(ctx context.Context, genInput *GenerateInput, genOutput *GenerateOutput) (plan.Plan, error) {
	if err := s.Generate(ctx, genInput, genOutput); err != nil {
		return plan.Plan{}, err
	}
	// Handle nested function calls (tool calls) in initial plan response.
	if genOutput.Content == "" && len(genOutput.Response.Choices) == 1 {
		choice := genOutput.Response.Choices[0]
		if len(choice.Message.ToolCalls) > 0 {
			steps := make(plan.Steps, 0, len(choice.Message.ToolCalls))
			for _, tc := range choice.Message.ToolCalls {
				name := tc.Name
				args := tc.Arguments
				if name == "" && tc.Function.Name != "" {
					name = tc.Function.Name
				}
				if args == nil && tc.Function.Arguments != "" {
					var parsed map[string]interface{}
					if err := json.Unmarshal([]byte(tc.Function.Arguments), &parsed); err == nil {
						args = parsed
					}
				}
				steps = append(steps, plan.Step{
					Type:   "tool",
					Name:   name,
					Args:   args,
					Reason: "auto-generated from assistant tool call",
				})
			}
			return plan.Plan{Steps: steps}, nil
		}
	}
	var aPlan plan.Plan
	if err := EnsureJSONResponse(ctx, genOutput.Content, &aPlan); err == nil {
		return aPlan, nil
	}
	return plan.Plan{}, nil
}
