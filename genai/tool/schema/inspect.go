package schema

// Package schema provides lightweight helpers to inspect dynamic (JSON Schema-like)
// tool input/output shapes for continuation and range support. It is intentionally
// tolerant to key casing and common alias names so it can work with schemas
// generated by various MCP servers.

import (
	"strings"

	mcpschema "github.com/viant/mcp-protocol/schema"
)

// ContinuationShape reports whether an output schema exposes continuation hints
// via nextRange with bytes and/or lines support.
type ContinuationShape struct {
	HasBytes bool
	HasLines bool
}

// RangeInputs reports whether an input schema accepts byte or line ranges.
type RangeInputs struct {
	HasBytes bool
	HasLines bool
}

// HasOutputContinuation returns true when the output schema contains a
// continuation object with a nextRange that includes either bytes or lines
// sub-objects having integer-typed fields.
func HasOutputContinuation(s any) (bool, ContinuationShape) {
	m := asMap(s)
	props := getProps(m)
	cont := getProps(getPropCI(props, "continuation"))
	if cont == nil {
		return false, ContinuationShape{}
	}
	nr := getProps(getPropCI(cont, "nextRange"))
	if nr == nil {
		return false, ContinuationShape{}
	}
	bytes := getProps(getPropCI(nr, "bytes"))
	lines := getProps(getPropCI(nr, "lines"))
	shape := ContinuationShape{}
	if hasByteFields(bytes) {
		shape.HasBytes = true
	}
	if hasLineFields(lines) {
		shape.HasLines = true
	}
	return (shape.HasBytes || shape.HasLines), shape
}

// HasInputRanges returns true when the input schema exposes any range selectors
// to request specific content windows. It checks common shapes: byteRange (from/to),
// bytesRange (offsetBytes/lengthBytes) and lineRange (startLine/lineCount).
func HasInputRanges(s any) (bool, RangeInputs) {
	m := asMap(s)
	props := getProps(m)
	ri := RangeInputs{}

	// byteRange { from, to } – treat as bytes range when at least from/offset exists.
	if brProps := getProps(getPropCI(props, "byteRange")); brProps != nil {
		fields := brProps
		if hasIntField(fields, []string{"from", "offset"}) {
			ri.HasBytes = true
		}
	}
	// bytesRange { offsetBytes, lengthBytes } – offset is decisive; length is optional.
	if br2Props := getProps(getPropCI(props, "bytesRange")); br2Props != nil {
		fields := br2Props
		if hasIntField(fields, []string{"offsetbytes", "offset"}) {
			ri.HasBytes = true
		}
	}
	// lineRange { startLine, lineCount } – startLine is decisive; count is optional.
	if lrProps := getProps(getPropCI(props, "lineRange")); lrProps != nil {
		fields := lrProps
		if hasIntField(fields, []string{"startline", "start"}) {
			ri.HasLines = true
		}
	}

	// Also support embedded ranges where offsetBytes and startLine are defined
	// directly on the root properties map (e.g., anonymous embedding of
	// textclip.BytesRange/LineRange). Length fields are optional.
	if hasIntField(props, []string{"offsetbytes", "offset"}) {
		ri.HasBytes = true
	}
	if hasIntField(props, []string{"startline", "start"}) {
		ri.HasLines = true
	}
	return (ri.HasBytes || ri.HasLines), ri
}

// ---- helpers ----

func asMap(v any) map[string]any {
	if v == nil {
		return nil
	}
	switch m := v.(type) {
	case map[string]interface{}:
		return map[string]any(m)
	case map[string]map[string]interface{}:
		out := make(map[string]any, len(m))
		for k, v := range m {
			out[k] = v
		}
		return out
	case mcpschema.ToolInputSchemaProperties:
		out := make(map[string]any, len(m))
		for k, v := range m {
			out[k] = v
		}
		return out
	default:
		return nil
	}
}

func getProps(obj map[string]any) map[string]any {
	if obj == nil {
		return nil
	}
	// JSON Schema typically stores nested fields under "properties".
	// If present, return that map. Otherwise, treat obj as if it's already a
	// properties map (helps when callers pass a properties map directly).
	if p, ok := obj["properties"]; ok {
		if m := asMap(p); m != nil {
			return m
		}
	}
	return obj
}

// getPropCI returns a child property from a properties map using
// case-insensitive key match.
func getPropCI(props map[string]any, key string) map[string]any {
	if props == nil {
		return nil
	}
	want := strings.ToLower(strings.TrimSpace(key))
	for k, v := range props {
		if strings.ToLower(k) == want {
			return asMap(v)
		}
	}
	return nil
}

func hasIntField(props map[string]any, aliases []string) bool {
	if props == nil {
		return false
	}
	for k, v := range props {
		lk := strings.ToLower(k)
		if !matchesAlias(lk, aliases) {
			continue
		}
		if isIntegerSchema(v) {
			return true
		}
	}
	return false
}

func matchesAlias(key string, aliases []string) bool {
	for _, a := range aliases {
		if key == strings.ToLower(a) {
			return true
		}
	}
	return false
}

func isIntegerSchema(v any) bool {
	m := asMap(v)
	if m == nil {
		return false
	}
	// Common JSON Schema form: { "type": "integer" } or ["integer","null"]
	if t, ok := m["type"]; ok {
		switch tv := t.(type) {
		case string:
			lt := strings.ToLower(tv)
			return lt == "integer" || lt == "number" // tolerate number
		case []any:
			for _, it := range tv {
				if s, ok := it.(string); ok {
					lt := strings.ToLower(s)
					if lt == "integer" || lt == "number" {
						return true
					}
				}
			}
		}
	}
	return false
}

func hasByteFields(bytes map[string]any) bool {
	if bytes == nil {
		return false
	}
	fields := getProps(bytes)
	if fields == nil {
		return false
	}
	// Accept either offset/length or offsetBytes/lengthBytes, from/to as a last resort.
	hasOff := hasIntField(fields, []string{"offsetbytes", "offset", "from"})
	hasLen := hasIntField(fields, []string{"lengthbytes", "length", "to"})
	return hasOff && hasLen
}

func hasLineFields(lines map[string]any) bool {
	if lines == nil {
		return false
	}
	fields := getProps(lines)
	if fields == nil {
		return false
	}
	return hasIntField(fields, []string{"startline", "start"}) && hasIntField(fields, []string{"linecount", "count"})
}
